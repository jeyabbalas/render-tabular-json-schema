<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Schema to Data Dictionary</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            padding: 20px;
            color: #2c3e50;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #718096;
            font-size: 14px;
        }

        .upload-section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            margin-bottom: 30px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: #4a69bd;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 500;
        }

        .file-input-label:hover {
            background: #3c5aa6;
        }

        .file-info {
            margin-left: 15px;
            color: #718096;
            font-size: 14px;
        }

        .actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #27ae60;
            color: white;
        }

        .btn-primary:hover {
            background: #229954;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .table-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            margin-bottom: 30px;
            height: 600px;
            display: flex;
            flex-direction: column;
        }

        .table-scroll-wrapper {
            overflow: auto;
            flex: 1;
            position: relative;
        }

        .table-header {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .table-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        thead th {
            background: #f1f3f5;
            padding: 14px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        thead th:nth-child(1) { width: 150px; } /* Variable Name */
        thead th:nth-child(2) { width: 300px; } /* Description */
        thead th:nth-child(3) { width: 110px; } /* Data Type */
        thead th:nth-child(4) { width: 140px; } /* Valid Values */
        thead th:nth-child(5) { width: 80px; }  /* Required */
        thead th:nth-child(6) { width: 150px; } /* Constraints */
        thead th:nth-child(7) { width: 120px; } /* Additional Info */

        tbody tr {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }

        tbody tr.data-row {
            animation: fadeIn 0.3s ease-in-out;
        }

        tbody tr.data-row.hidden {
            opacity: 0;
            transform: scaleY(0);
            height: 0;
            overflow: hidden;
            animation: fadeOut 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scaleY(1);
            }
            to {
                opacity: 0;
                transform: scaleY(0);
            }
        }

        tbody tr:hover {
            background: #f8f9fa;
        }

        tbody td {
            padding: 14px 16px;
            border-bottom: 1px solid #e9ecef;
            font-size: 14px;
            vertical-align: top;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .category-row {
            background: #e3f2fd;
            font-weight: 600;
            color: #1565c0;
        }

        .category-row td {
            padding: 12px 16px;
            border-bottom: 2px solid #90caf9;
        }

        .variable-name {
            font-weight: 600;
            color: #2c3e50;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
        }

        .data-type {
            display: inline-block;
            padding: 3px 8px;
            background: #e8f4f8;
            color: #0277bd;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .required-badge {
            display: inline-block;
            padding: 2px 6px;
            background: #27ae60;
            color: white;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .optional-badge {
            display: inline-block;
            padding: 2px 6px;
            background: #95a5a6;
            color: white;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .enum-container {
            position: relative;
            display: inline-block;
        }

        .enum-toggle {
            cursor: pointer;
            color: #3498db;
            text-decoration: underline;
            font-size: 13px;
            transition: color 0.2s ease;
        }

        .enum-toggle:hover {
            color: #2980b9;
        }

        .enum-list {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px 0;
            z-index: 100;
            min-width: 250px;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
            top: 100%;
            left: 0;
            margin-top: 5px;
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .enum-list.show {
            display: block;
        }

        .enum-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f1f3f5;
            font-size: 13px;
            transition: background-color 0.2s ease;
            cursor: default;
        }

        .enum-item:hover {
            background-color: #e3f2fd;
        }

        .enum-item:last-child {
            border-bottom: none;
        }

        .enum-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .enum-desc {
            color: #718096;
            font-size: 12px;
            margin-top: 2px;
        }

        .const-value {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            color: #2c3e50;
        }

        .constraint {
            display: inline-block;
            margin-right: 8px;
            margin-bottom: 4px;
            padding: 2px 6px;
            background: #fef5e7;
            color: #d68910;
            border-radius: 3px;
            font-size: 12px;
        }

        .additional-info {
            cursor: pointer;
            color: #3498db;
            font-size: 12px;
            text-decoration: underline;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .additional-info:hover {
            color: #2980b9;
        }

        .additional-content {
            max-height: 0;
            overflow: hidden;
            margin-top: 0;
            padding: 0;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 12px;
            color: #495057;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            word-break: break-all;
        }

        .additional-content.show {
            max-height: 500px;
            margin-top: 8px;
            padding: 8px;
            opacity: 1;
        }

        .additional-content .property {
            margin-bottom: 4px;
        }

        .additional-content .property strong {
            color: #2c3e50;
        }

        .search-box {
            margin-bottom: 20px;
            padding: 0 30px;
        }

        .search-input {
            width: 100%;
            max-width: 400px;
            padding: 10px 15px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #4a69bd;
            box-shadow: 0 0 0 3px rgba(74, 105, 189, 0.1);
        }

        .error-message {
            background: #fee;
            color: #c00;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>JSON Schema → Data Dictionary Converter</h1>
            <p class="subtitle">Transform JSON Schema into familiar tabular data dictionary format</p>
        </header>

        <div class="upload-section">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept=".json" multiple>
                <label for="fileInput" class="file-input-label">
                    Choose JSON Schema File(s)
                </label>
                <span class="file-info" id="fileInfo">No files selected</span>
            </div>
            <div class="actions">
                <button id="processBtn" class="btn btn-primary" style="display:none;">Generate Table</button>
                <button id="exportBtn" class="btn btn-secondary" style="display:none;">Export to CSV</button>
            </div>
            <div id="errorMessage"></div>
        </div>

        <div id="tableOutput"></div>
    </div>

    <script>
        class SchemaProcessor {
            constructor() {
                this.schemas = new Map();
                this.mainSchema = null;
            }

            async processFiles(files) {
                this.schemas.clear();
                this.mainSchema = null;

                // Load all schemas
                for (const file of files) {
                    const text = await file.text();
                    const schema = JSON.parse(text);

                    if (schema.$id) {
                        this.schemas.set(schema.$id, schema);
                    } else {
                        // Schema without $id - treat as potential main schema
                        this.schemas.set(file.name, schema);
                    }

                    // Identify main schema (has type: array)
                    if (schema.type === 'array' && schema.items) {
                        this.mainSchema = schema;
                    }
                }

                // If no main schema found, try to use single schema
                if (!this.mainSchema && this.schemas.size === 1) {
                    this.mainSchema = this.schemas.values().next().value;
                }

                return this.mainSchema !== null;
            }

            resolveRef(ref, baseSchema) {
                if (ref.startsWith('#')) {
                    // Internal reference
                    const path = ref.substring(2).split('/');
                    let current = baseSchema;
                    for (const segment of path) {
                        current = current[segment];
                        if (!current) return null;
                    }
                    return current;
                } else {
                    // External reference
                    for (const [id, schema] of this.schemas) {
                        if (id.endsWith(ref) || ref.endsWith(id)) {
                            return schema;
                        }
                    }
                    // Try simple filename match
                    return this.schemas.get(ref) || null;
                }
            }

            extractProperties(schema, category = null) {
                const result = [];

                if (schema.properties) {
                    for (const [name, propSchema] of Object.entries(schema.properties)) {
                        result.push({
                            category: category,
                            name: name,
                            schema: propSchema,
                            required: schema.required?.includes(name) || false
                        });
                    }
                }

                if (schema.allOf) {
                    for (const subSchema of schema.allOf) {
                        if (subSchema.$ref) {
                            const resolved = this.resolveRef(subSchema.$ref, schema);
                            if (resolved) {
                                const subCategory = resolved.title || category;
                                result.push(...this.extractProperties(resolved, subCategory));
                            }
                        } else {
                            result.push(...this.extractProperties(subSchema, category));
                        }
                    }
                }

                return result;
            }

            getTableData() {
                if (!this.mainSchema) return null;

                let itemSchema = this.mainSchema.items;
                if (itemSchema?.$ref) {
                    itemSchema = this.resolveRef(itemSchema.$ref, this.mainSchema);
                }

                if (!itemSchema) return null;

                const properties = this.extractProperties(itemSchema);

                return {
                    title: this.mainSchema.title || 'Dataset Schema',
                    description: this.mainSchema.description || '',
                    properties: properties
                };
            }
        }

        class TableRenderer {
            formatType(schema) {
                let type = schema.type || 'any';
                if (schema.format) {
                    return `${type} (${schema.format})`;
                }
                return type;
            }

            formatConstraints(schema) {
                const constraints = [];

                if (schema.minimum !== undefined || schema.maximum !== undefined) {
                    const min = schema.minimum ?? (schema.exclusiveMinimum !== undefined ? `>${schema.exclusiveMinimum}` : '');
                    const max = schema.maximum ?? (schema.exclusiveMaximum !== undefined ? `<${schema.exclusiveMaximum}` : '');
                    if (min || max) {
                        constraints.push(`Range: ${min}${(min !== '' && max !== '') ? '-' : ''}${max}`);
                    }
                }

                if (schema.minLength || schema.maxLength) {
                    const len = schema.minLength === schema.maxLength ?
                        `${schema.minLength} chars` :
                        `${schema.minLength || '0'}-${schema.maxLength || '∞'} chars`;
                    constraints.push(len);
                }

                if (schema.pattern) {
                    constraints.push(`Pattern: ${schema.pattern}`);
                }

                if (schema.multipleOf) {
                    constraints.push(`Multiple of ${schema.multipleOf}`);
                }

                return constraints;
            }

            formatConstraintsForCSV(schema) {
                const constraints = this.formatConstraints(schema);
                return constraints.join('\n');
            }

            formatEnum(schema) {
                if (!schema.enum) return '';

                const hasDescriptions = schema.enumDescriptions &&
                    Array.isArray(schema.enumDescriptions) &&
                    schema.enumDescriptions.length === schema.enum.length;

                const enumId = 'enum_' + Math.random().toString(36).substr(2, 9);

                let html = `<div class="enum-container">
                    <span class="enum-toggle" onclick="toggleEnum('${enumId}')">
                        ${schema.enum.length} values ▼
                    </span>
                    <div id="${enumId}" class="enum-list">`;

                schema.enum.forEach((value, index) => {
                    const desc = hasDescriptions ? schema.enumDescriptions[index] : '';
                    html += `<div class="enum-item">
                        <div class="enum-value">${value}</div>
                        ${desc ? `<div class="enum-desc">${desc}</div>` : ''}
                    </div>`;
                });

                html += `</div></div>`;
                return html;
            }

            formatEnumForCSV(schema) {
                if (!schema.enum) return '';

                const hasDescriptions = schema.enumDescriptions &&
                    Array.isArray(schema.enumDescriptions) &&
                    schema.enumDescriptions.length === schema.enum.length;

                if (hasDescriptions) {
                    return schema.enum.map((value, index) =>
                        `${value}: ${schema.enumDescriptions[index]}`
                    ).join('\n');
                } else {
                    return schema.enum.join('\n');
                }
            }

            formatAdditional(schema) {
                const exclude = ['type', 'format', 'description', 'enum', 'enumDescriptions',
                               'minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum',
                               'minLength', 'maxLength', 'pattern', 'const', 'multipleOf'];

                const additional = {};
                for (const [key, value] of Object.entries(schema)) {
                    if (!exclude.includes(key)) {
                        additional[key] = value;
                    }
                }

                if (Object.keys(additional).length === 0) return '';

                const addId = 'add_' + Math.random().toString(36).substr(2, 9);
                return `<span class="additional-info" onclick="toggleAdditional('${addId}')">
                    More info...
                </span>
                <div id="${addId}" class="additional-content">
                    ${Object.entries(additional).map(([k, v]) =>
                        `<div class="property"><strong>${k}:</strong> ${JSON.stringify(v)}</div>`
                    ).join('')}
                </div>`;
            }

            formatAdditionalForCSV(schema) {
                const exclude = ['type', 'format', 'description', 'enum', 'enumDescriptions',
                               'minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum',
                               'minLength', 'maxLength', 'pattern', 'const', 'multipleOf'];

                const additional = [];
                for (const [key, value] of Object.entries(schema)) {
                    if (!exclude.includes(key)) {
                        additional.push(`${key}: ${JSON.stringify(value)}`);
                    }
                }

                return additional.join('\n');
            }

            render(data) {
                if (!data) return '<div class="error-message">No valid schema data to display</div>';

                const hasCategories = data.properties.some(p => p.category);

                let html = `<div class="table-container">
                    <div class="table-header">
                        <div class="table-title">${data.title}</div>
                        ${data.description ? `<div class="subtitle">${data.description}</div>` : ''}
                    </div>
                    <div class="search-box">
                        <input type="text" class="search-input" id="searchInput"
                               placeholder="Search variables..." onkeyup="filterTable()">
                    </div>
                    <div class="table-scroll-wrapper">
                        <table id="dataTable">
                            <thead>
                                <tr>
                                    <th>Variable Name</th>
                                    <th>Description</th>
                                    <th>Data Type</th>
                                    <th>Valid Values</th>
                                    <th>Required</th>
                                    <th>Constraints</th>
                                    <th>Additional Info</th>
                                </tr>
                            </thead>
                            <tbody>`;

                let lastCategory = null;
                for (const prop of data.properties) {
                    // Add category row if changed
                    if (hasCategories && prop.category && prop.category !== lastCategory) {
                        html += `<tr class="category-row">
                            <td colspan="7">${prop.category}</td>
                        </tr>`;
                        lastCategory = prop.category;
                    }

                    const constraints = this.formatConstraints(prop.schema);

                    html += `<tr class="data-row">
                        <td><span class="variable-name">${prop.name}</span></td>
                        <td>${prop.schema.description || ''}</td>
                        <td><span class="data-type">${this.formatType(prop.schema)}</span></td>
                        <td>${prop.schema.const !== undefined ?
                            `<span class="const-value">${prop.schema.const}</span>` :
                            this.formatEnum(prop.schema)}</td>
                        <td>${prop.required ?
                            '<span class="required-badge">Yes</span>' :
                            '<span class="optional-badge">No</span>'}</td>
                        <td>${constraints.map(c => `<span class="constraint">${c}</span>`).join(' ')}</td>
                        <td>${this.formatAdditional(prop.schema)}</td>
                    </tr>`;
                }

                html += `</tbody></table></div></div>`;
                return html;
            }

            exportToCSV(data) {
                if (!data) return '';

                const headers = ['Category', 'Variable Name', 'Description', 'Data Type', 'Valid Values', 'Required', 'Constraints', 'Additional Info'];
                const rows = [headers];

                let currentCategory = '';
                for (const prop of data.properties) {
                    if (prop.category && prop.category !== currentCategory) {
                        currentCategory = prop.category;
                    }

                    const validValues = prop.schema.const !== undefined ?
                        String(prop.schema.const) :
                        this.formatEnumForCSV(prop.schema);

                    const row = [
                        currentCategory || '',
                        prop.name,
                        prop.schema.description || '',
                        this.formatType(prop.schema),
                        validValues,
                        prop.required ? 'Yes' : 'No',
                        this.formatConstraintsForCSV(prop.schema),
                        this.formatAdditionalForCSV(prop.schema)
                    ];
                    rows.push(row);
                }

                // Format for Excel with proper escaping
                return rows.map(row =>
                    row.map(cell => {
                        const cellStr = String(cell).replace(/"/g, '""');
                        // Always quote cells that contain newlines, commas, or quotes
                        if (cellStr.includes('\n') || cellStr.includes(',') || cellStr.includes('"')) {
                            return `"${cellStr}"`;
                        }
                        return cellStr;
                    }).join(',')
                ).join('\n');
            }
        }

        // Global functions for event handlers
        window.toggleEnum = function(id) {
            const element = document.getElementById(id);
            element.classList.toggle('show');
        };

        window.toggleAdditional = function(id) {
            const element = document.getElementById(id);
            element.classList.toggle('show');
        };

        window.filterTable = function() {
            const input = document.getElementById('searchInput');
            const filter = input.value.toLowerCase();
            const rows = document.querySelectorAll('#dataTable tbody .data-row');

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                if (text.includes(filter)) {
                    row.classList.remove('hidden');
                } else {
                    row.classList.add('hidden');
                }
            });
        };

        // Initialize
        const processor = new SchemaProcessor();
        const renderer = new TableRenderer();
        let currentData = null;

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            const fileInfo = document.getElementById('fileInfo');
            const processBtn = document.getElementById('processBtn');
            const errorMessage = document.getElementById('errorMessage');

            if (files.length === 0) {
                fileInfo.textContent = 'No files selected';
                processBtn.style.display = 'none';
                return;
            }

            fileInfo.textContent = files.length === 1 ?
                files[0].name :
                `${files.length} files selected`;

            processBtn.style.display = 'inline-block';
            errorMessage.innerHTML = '';
        });

        document.getElementById('processBtn').addEventListener('click', async () => {
            const files = Array.from(document.getElementById('fileInput').files);
            const errorMessage = document.getElementById('errorMessage');
            const tableOutput = document.getElementById('tableOutput');
            const exportBtn = document.getElementById('exportBtn');

            try {
                tableOutput.innerHTML = '<div class="loading">Processing schemas...</div>';

                const success = await processor.processFiles(files);

                if (!success) {
                    throw new Error('Could not identify main schema. Please ensure one schema has type: "array" with items.');
                }

                currentData = processor.getTableData();
                tableOutput.innerHTML = renderer.render(currentData);
                exportBtn.style.display = 'inline-block';

            } catch (error) {
                errorMessage.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                tableOutput.innerHTML = '';
                exportBtn.style.display = 'none';
            }
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            if (!currentData) return;

            const csv = renderer.exportToCSV(currentData);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'data_dictionary.csv';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Close enum dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('enum-toggle')) {
                document.querySelectorAll('.enum-list.show').forEach(el => {
                    el.classList.remove('show');
                });
            }
        });
    </script>
</body>
</html>